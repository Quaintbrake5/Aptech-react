import { __assign, __extends } from "tslib";
/**
 * @fileOverview Default Legend Content
 */
import React, { PureComponent } from 'react';
import classNames from 'classnames';
import { Surface } from 'recharts/lib/container/Surface';
import { Symbols } from 'recharts/lib/shape/Symbols';
import './DefaultLegendScrollbableContent.css';
import { adaptEventsOfChild, } from '../util/types';
var SIZE = 32;
export var DefaultLegendScrollableContent = /** @class */ (function (_super) {
    __extends(DefaultLegendScrollableContent, _super);
    function DefaultLegendScrollableContent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Render the path of icon
     * @param {Object} data Data of each legend item
     * @return {String} Path element
     */
    DefaultLegendScrollableContent.prototype.renderIcon = function (data) {
        var inactiveColor = this.props.inactiveColor;
        var halfSize = SIZE / 2;
        var sixthSize = SIZE / 6;
        var thirdSize = SIZE / 3;
        var color = data.inactive ? inactiveColor : data.color;
        if (data.type === 'plainline') {
            return (React.createElement("line", { strokeWidth: 4, fill: 'none', stroke: color, strokeDasharray: data.payload.strokeDasharray, x1: 0, y1: halfSize, x2: SIZE, y2: halfSize, className: 'recharts-legend-icon' }));
        }
        if (data.type === 'line') {
            return (React.createElement("path", { strokeWidth: 4, fill: 'none', stroke: color, d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize), className: 'recharts-legend-icon' }));
        }
        if (data.type === 'rect') {
            return (React.createElement("path", { stroke: 'none', fill: color, d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat((SIZE * 3) / 4, "h").concat(-SIZE, "z"), className: 'recharts-legend-icon' }));
        }
        if (React.isValidElement(data.legendIcon)) {
            var iconProps = __assign({}, data);
            delete iconProps.legendIcon;
            return React.cloneElement(data.legendIcon, iconProps);
        }
        return (React.createElement(Symbols, { fill: color, cx: halfSize, cy: halfSize, size: SIZE, sizeType: 'diameter', type: data.type }));
    };
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
    DefaultLegendScrollableContent.prototype.renderItems = function () {
        var _a;
        var _this = this;
        var payload = (_a = this.props, _a.payload), iconSize = _a.iconSize, layout = _a.layout, formatter = _a.formatter, inactiveColor = _a.inactiveColor;
        var viewBox = { x: 0, y: 0, width: SIZE, height: SIZE };
        var itemStyle = {
            display: layout === 'horizontal' ? 'inline-block' : 'block',
            marginRight: 10,
        };
        var svgStyle = { display: 'inline-block', verticalAlign: 'middle', marginRight: 4 };
        return payload.map(function (entry, i) {
            var _a;
            var finalFormatter = entry.formatter || formatter;
            var className = classNames((_a = {
                    'recharts-legend-item': true
                },
                _a["legend-item-".concat(i)] = true,
                _a.inactive = entry.inactive,
                _a));
            if (entry.type === 'none') {
                return null;
            }
            var color = entry.inactive ? inactiveColor : entry.color;
            return (React.createElement("li", __assign({ className: className, style: itemStyle, key: "legend-item-".concat(i) }, adaptEventsOfChild(_this.props, entry, i)),
                React.createElement(Surface, { width: iconSize, height: iconSize, viewBox: viewBox, style: svgStyle }, _this.renderIcon(entry)),
                React.createElement("span", { className: 'recharts-legend-item-text', style: { color: color } }, finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value)));
        });
    };
    DefaultLegendScrollableContent.prototype.render = function () {
        var _a;
        var payload = (_a = this.props, _a.payload), layout = _a.layout, align = _a.align, chartHeight = _a.chartHeight, contentMaxHeight = _a.contentMaxHeight, scrollbarStyle = _a.scrollbarStyle;
        if (!payload || !payload.length) {
            return null;
        }
        var finalStyle = {
            padding: 0,
            margin: 0,
        };
        if (layout === 'horizontal') {
            finalStyle.textAlign = align;
            finalStyle.maxHeight = contentMaxHeight;
            finalStyle.overflowX = 'auto';
        }
        else {
            finalStyle.textAlign = 'left';
            finalStyle.maxHeight = chartHeight + 2;
            finalStyle.overflowY = 'auto';
        }
        var className = 'recharts-default-legend recharts-scrollable-legend';
        if (scrollbarStyle !== 'none') {
            className = "".concat(className, " recharts-scrollable-legend-").concat(scrollbarStyle);
        }
        return (React.createElement("ul", { className: className, style: finalStyle }, this.renderItems()));
    };
    DefaultLegendScrollableContent.displayName = 'Legend';
    DefaultLegendScrollableContent.defaultProps = {
        iconSize: 14,
        layout: 'horizontal',
        align: 'center',
        verticalAlign: 'middle',
        inactiveColor: '#ccc',
        contentMaxHeight: 50,
        scrollbarStyle: 'default',
    };
    return DefaultLegendScrollableContent;
}(PureComponent));
//# sourceMappingURL=DefaultLegendScrollableContent.js.map